---
title: Optimistic mutation results
description: Update your UI before your server responds
---

It's often possible to predict a mutation operation's most likely result _before_ your GraphQL server returns it. Apollo Client can use this "most likely result" to update your UI **optimistically**, making your app feel more responsive to the user.

For example, let's say we have a blog application that supports the following mutation:

```graphql
type Mutation {
  updateComment(commentId: ID!, content: String!): Comment!
  
  # ...other mutations...
}
```

If a user edits an existing comment on a post, the app executes the `updateComment` mutation, which returns a `Comment` object with updated `content`.

Our app knows what the updated `Comment` object will probably look like, which means it can optimistically update its UI to display the update _before_ the GraphQL server responds with it. If our app is wrong (e.g., the GraphQL server responds with an _unchanged_ `Comment` due to an error), the UI will automatically update to reflect the _actual_ response.

## The `optimisticResponse` option

To enable this optimistic UI behavior, we provide an `optimisticResponse` option to the [mutate function](../data/mutations/#calling-the-mutate-function) we use to execute our mutation.

Let's look at some code:

```jsx{20-27}:title=CommentPageWithData.jsx
// Mutation definition
const UPDATE_COMMENT = gql`
  mutation UpdateComment($commentId: ID!, $commentContent: String!) {
    updateComment(commentId: $commentId, content: $commentContent) {
      id
      __typename
      content
    }
  }
`;

// Component definition
function CommentPageWithData() {
  const [mutate] = useMutation(UPDATE_COMMENT);
  return (
    <Comment
      updateComment={({ commentId, commentContent }) =>
        mutate({
          variables: { commentId, commentContent },
          optimisticResponse: {
            __typename: "Mutation",
            updateComment: {
              id: commentId,
              __typename: "Comment",
              content: commentContent
            }
          }
        })
      }
    />
  );
}
```

As this example shows, the value of `optimisticResponse` is an object that matches the shape of the mutation response we expect from the server. Importantly, this includes the `Comment`'s `id` and `__typename` fields. The Apollo Client cache uses these values to generate the comment's [unique cache identifier](../caching/cache-configuration/#default-identifier-generation) (e.g., `Comment:12`).

## Optimistic mutation lifecycle

1. When the code above calls `mutate`, the Apollo Client cache stores a `Comment` object with the field values specified in `optimisticResponse`. _However_, it does not overwrite the _existing_ cached `Comment` with the same cache identifier. Instead, it stores a separate, _optimistic_ version of the object. This ensures that our cached data remains accurate if our `optimisticResponse` is wrong.

2. Apollo Client notifies all active queries that include the modified comment. Those queries automatically update, and their associated components re-render to reflect the optimistic data. Because this doesn't require any network requests, it's nearly instantaneous to the user.

3. Eventually, our server responds with the mutation's _actual_ resulting  `Comment` object.

4. The Apollo Client cache removes the optimistic version of the `Comment` object. It also overwrites the _canonical_ cached version with values returned from the server.

5. Apollo Client notifies all affected queries again. The associated components re-render, but if the server's response matches our `optimisticResponse`, this is invisible to the user.

## Adding to a list

In the example above, we showed how to seamlessly edit an existing object in the store with an optimistic mutation result. However, many mutations don't just update an existing object in the store, but they insert a new one.

In that case we need to specify how to integrate the new data into existing queries, and thus our UI. You can read in detail about how to do that in the article about [interacting with cached data](../caching/cache-interaction/)--in particular, we can use the `update` function to insert a result into an existing query's result set. `update` works exactly the same way for optimistic results and the real results returned from the server.

Here is a concrete example from GitHunt, which inserts a comment into an existing list of comments.

```jsx
const SUBMIT_COMMENT_MUTATION = gql`
  mutation SubmitComment($repoFullName: String!, $commentContent: String!) {
    submitComment(
      repoFullName: $repoFullName
      commentContent: $commentContent
    ) {
      postedBy {
        login
        html_url
      }
      createdAt
      content
    }
  }
`;

function CommentsPageWithMutations({ currentUser }) {
  const [mutate] = useMutation(SUBMIT_COMMENT_MUTATION);
  return (
    <CommentsPage
      submit={(repoFullName, commentContent) =>
        mutate({
          variables: { repoFullName, commentContent },
          optimisticResponse: {
            __typename: "Mutation",
            submitComment: {
              __typename: "Comment",
              postedBy: currentUser,
              createdAt: new Date(),
              content: commentContent
            }
          },
          update: (proxy, { data: { submitComment } }) => {
            // Read the data from our cache for this query.
            const data = proxy.readQuery({ query: CommentAppQuery });
            // Write our data back to the cache with the new comment in it
            proxy.writeQuery({ query: CommentAppQuery, data: {
              ...data,
              comments: [...data.comments, submitComment]
            }});
          }
        })
      }
    />
  );
}
```
