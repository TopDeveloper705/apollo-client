---
title: Managing local state with field policies
sidebar_title: Field policies
description: Control and reactively respond to local state changes
---

import { ExpansionPanel } from 'gatsby-theme-apollo-docs/src/components/expansion-panel';

**Field policies** define custom logic for how individual GraphQL fields are written to and fetched from your Apollo Client cache. To manage local state with field policies, you can define policies for fields that aren't in your back-end schema. You can then include these local-only fields alongside schema-backed fields in your GraphQL queries.

> Field policies are primarily documented in [Customizing the behavior of cached fields](../caching/cache-field-behavior/). This article specifically describes how to use them to manage local state.

## Querying a local-only field

Let's say we're building an e-commerce website. Most of a product's details are stored on our back-end server, but we might want to define an `isInCart` boolean field that's local to a particular client.

### Use the `@client` directive

To fetch a particular product's details _including_ its local cart status, we can write a query like this one:

```js{6}
const GET_PRODUCT_DETAILS = gql`
  query ProductDetails($productId: ID!) {
    product(id: $productId) {
      name
      price
      isInCart @client
    }
  }
`;
```

The `@client` directive above tells Apollo Client that the `isInCart` field is always calculated locally. To prevent errors, Apollo Client strips `isInCart` from this query before sending it to our server to fetch values for `name` and `price`. The final query result is returned only after all local _and_ remote fields are populated.

> **Note:** If you apply the `@client` directive to a field with subfields, the directive is automatically applied to all subfields.
> 
> <ExpansionPanel title="See example">
> 
> ```js{6-9}
> const GET_PRODUCT_DETAILS = gql`
  query ProductDetails($productId: ID!) {
    product(id: $productId) {
      name
      price
      purchaseStatus @client {
        isInCart
        isOnWishlist
      }
    }
  }
`;
> ```
>
> </ExpansionPanel>

Now we need to define a field policy that describes _how_ the `isInCart` field is calculated locally.

### Define a field policy

You define your application's field policies in a map that you provide to the constructor of Apollo Client's `InMemoryCache`. Each field policy is a child of a particular _type_ policy (much like the corresponding field is a child of a particular type).

Here's a sample `InMemoryCache` constructor that defines a field policy for `Product.isInCart`:

```js
const cache = new InMemoryCache({
  typePolicies: { // Type policy map
    Product: {
      fields: { // Field policy map for the Product type
        isInCart: { // Field policy for the isInCart field
          read(_, { variables }) { // The read function for the isInCart field
            return localStorage.getItem('CART').includes(
              variables.productId
            );
          }
        }
      }
    }
  }
});
```

The field policy above defines a [`read` function](../caching/cache-field-behavior/#the-read-function) for the `isInCart` field. Whenever you query a field that has a `read` function, the cache calls that function to calculate the field's value. In this case, the `read` function returns whether the queried product's ID is in the `CART` array in `localStorage`.

> By default, if you don't define a `read` function for a local-only field, the cache checks whether the field exists in its cached version of the corresponding type. For details, see [Local data query flow](./querying-and-updating#local-data-query-flow).

You can use `read` functions to perform any sort of logic you want, including:

* Manually executing other cache operations
* Calling helper utilities or libraries to prepare, validate, or sanitize data
* Fetching data from a separate store
* Registering usage metrics

## Using reactive variables to track `@client` state

You can pair field policies with Apollo Client [reactive variables](./reactive-variables) to help make the processing and running of GraphQL queries more dynamic and reactive, to updates in other parts of your application.

To understand how reactive variables and field policies can work together, let's say we're building an ecommerce web application. As part of this system we're tracking items in a client side shopping cart, where the shopping cart is a simple list of product ID's. To list the items in the shopping cart, we're using the following query and `Cart` component:

```jsx
export const GET_CART_ITEMS = gql`
  query GetCartItems {
    cartItems @client
  }
`;

export function Cart() {
  const { data, loading, error } = useQuery(GET_CART_ITEMS);

  if (loading) return <Loading />;
  if (error) return <p>ERROR: {error.message}</p>;

  return (
    <div class="cart">
      <Header>My Cart</Header>
      {data && data.cartItems.length === 0 ? (
        <p>No items in your cart</p>
      ) : (
        <Fragment>
          {data && data.cartItems.map(productId => (
            <CartItem key={productId} launchId={productId} />
          ))}
        </Fragment>
      )}
    </div>
  );
}
```

The `@client` based `cartItems` field in the `GET_CART_ITEMS` query is calculated by the following locally defined `cartItems` field policy `read` function:

```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        cartItems: {
          read() {
            // Return all cart items from the client side cart
          }
        }
      }
    }
  }
});
```

To track the contents of our client side shopping cart, we have several options. We could store the cart contents in `localStorage`, we could write them directly into the Apollo Client cache using `cache.writeQuery`, we could store them using some other state management system like Redux, etc. While all of these choices have their advantages/disadvantages, the one thing we want to make sure of is that when a customer makes changes to their shopping cart, we want those changes to automatically trigger the rendering of our `Cart` component, to show the most recent state of the shopping cart.

Storing and managing our shopping cart in the Apollo Client cache would help address our requirement of re-rendering the `Cart` component when there are changes. `useQuery` watches for query changes in the cache, then automatically re-runs when it finds them. This means that we could follow a pattern of updating the shopping cart in the cache when a user makes changes to it, using `cache.writeQuery`, and reading from the cache in our `cartItems` field policy `read` function above, using `cache.readQuery`. While this would work, using `cache.writeQuery` / `cache.readQuery` introduces a fair amount of boilerplate to interact with the cache stored shopping cart. This boilerplate is important when we want to ensure the structure and integrity of the graph based data we're managing in the cache, but in our case the shopping cart is really just a simple list of product IDs. Wouldn't it be great if our shopping cart could just be a simple in-memory array, but have changes to the cart array tracked such that they're tied into Apollo Client's change broadcast system? In other words have changes made to the shopping cart array trigger a re-render of the `Cart` component, with the latest cart contents? Reactive variables to the rescue!

As mentioned in the [reactive variables](./reactive-variables) section of these docs, reactive variables give us a simple way to track client side state, while having changes to that state tracked using Apollo Client's dependency tracking mechanism. Let's take a look at how we can leverage a reactive variable to track our shopping cart state. First, let's setup a reactive variable:

```js:title=cache.js
export const cartItemsVar = cache.makeVar([]);
```

`cartItemsVar` will hold our shopping cart contents, and has been initialized as an empty array. Next, let's wire our new `cartItemsVar` reactive variable into our `cartItems` field policy:

```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        cartItems: {
          read() {
            return cartItemsVar();
          }
        }
      }
    }
  }
});
```

Now whenever our `cartItems` field policy is triggered, the current value of our cart reactive variable will be returned. This means that when our `GET_CART_ITEMS` query runs, its `cartItems @client` field will return the value of `cartItemsVar`.

Now that we've wired a reactive variable up to help display our cart contents, let's take a look at how we can add a new product to our cart:

```jsx
import { cartItemsVar } from './cache';
// ... other imports

export function AddToCartButton({ productId }) {
  const cartItems = cartItemsVar();
  return (
    <div class="add-to-cart-button">
      <Button onClick={() => cartItemsVar([...cartItems, productId])}>
        Add to Cart
      </Button>
    </div>
  );
}
```

When a customer clicks on our add to cart button, we combine the newly selected `productId` with the existing contents of our reactive variable cart, setting the new combination as the value of `cartItemsVar`. When this happens, Apollo Client notifies any query that has been wired up to use `cartItemsVar` in a field policy, of the changes. Since we're using `cartItems @client` in our `GET_CART_ITEMS` query above, this means our `useQuery` based `Cart` component will automatically re-render to show the updated cart.

If we wanted to store and manage our cart in the cache, to add a new product to the cart we would either fire a local mutation using something like `useMutation`, or manipulate the cache directly using something like `cache.writeQuery` / `cache.writeFragment`. Given the basic needs of our shopping cart however, leveraging reactive variables to manage cart data in a simple array, but still be able to participate in Apollo Client's change notification workflow, leads to less boilerplate and more flexibility. Apollo Client's cache is primarily optimized for storing normalized graph based data, which means the format of the data stored in the cache is restricted. While this can be adjusted by [disabling normalization](../caching/cache-configuration/#disabling-normalization), reactive variables have no restrictions when it comes to storing data. The are simple state containers, and can hold anything ranging from JSON to functions and more.

The above example really only scratches the surface of what reactive variables combined with field policies can accomplish. Reactive variables introduce a new exciting way of handling state in Apollo Client, and we can't wait to see what you build with them!

## Handling `@client` fields with the cache

As outlined in [Handling `@client` fields with field policies](#handling-client-fields-with-field-policies), `@client` fields can be resolved with the help of field policy functions. However, it's important to note that field policies are not always required when using the `@client` directive. Fields marked with `@client` can still be resolved locally, by pulling matching values out of the cache directly. For example:

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import {
  ApolloClient,
  InMemoryCache,
  ApolloProvider,
  useQuery,
  gql
} from '@apollo/client';

import Pages from './pages';
import Login from './pages/login';

const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache(),
});

const IS_LOGGED_IN = gql`
  query IsUserLoggedIn {
    isLoggedIn @client
  }
`;

cache.writeQuery({
  query: IS_LOGGED_IN,
  data: {
    isLoggedIn: !!localStorage.getItem("token"),
  },
});

function App() {
  const { data } = useQuery(IS_LOGGED_IN);
  return data.isLoggedIn ? <Pages /> : <Login />;
}

ReactDOM.render(
  <ApolloProvider client={client}>
    <App />
  </ApolloProvider>,
  document.getElementById("root"),
);
```

In the above example, we first prepare the cache using `cache.writeQuery` to store a value for the `isLoggedIn` field. We then run the `IS_LOGGED_IN` query via an Apollo Client `useQuery` hook, which includes an `@client` directive. When Apollo Client executes the `IS_LOGGED_IN` query, it first looks for a field policy function that can be used to handle the `@client` field. When it can't find one, it falls back on trying to pull the specified field out of the cache. So in this case, the `data` value returned by the `useQuery` hook has a `isLoggedIn` property available, which includes the `isLoggedIn` result (`!!localStorage.getItem('token')`) pulled directly from the cache.

Pulling `@client` field values directly out of the cache isn't quite as flexible as using field policy functions, since they can perform extra computations before returning a result. Depending on your application's needs however, loading `@client` fields directly from the cache might be a simpler option. Apollo Client doesn't restrict combining both approaches, so feel free to mix and match. If the need arises, you can pull some `@client` values directly from the cache, and calculate others others using field policies, all in the same query.

## Using local-only fields as GraphQL variables

If your GraphQL query uses variables, the local-only fields of that query can provide the _values_ of those variables.

To do so, you apply the `@export(as: "variableName")` directive, like so:

```js
const query = gql`
  query CurrentAuthorPostCount($authorId: Int!) {
    currentAuthorId @client @export(as: "authorId")
    postCount(authorId: $authorId)
  }
`;
```

In the query above, the result of the local-only field `currentAuthorId` is used as the value of the `$authorId` variable that's passed to `postCount`. 

You can even do this if `postCount` is _also_ a local-only field (i.e., if it's also marked as `@client`).

### Considerations for using `@export`

* To use the `@export` directive, a field **must also** use the `@client` directive. In other words, only local-only fields can be used as variable values. 

* If multiple fields in an operation use the `@export` directive to assign their value to the _same_ variable, the field listed _last_ takes precedence. When this happens in development mode, Apollo Client logs a warning message.

* At first glance, the `@export` directive appears to violate the [GraphQL specification's requirement](https://graphql.github.io/graphql-spec/draft/#sec-Normal-and-Serial-Execution) that the execution order of an operation must not affect its result:

    > …the resolution of fields other than top‐level mutation fields must always be side effect‐free and idempotent, the execution order must not affect the result, and hence the server has the freedom to execute the field entries in whatever order it deems optimal.

    However, all variable values are populated _before_ an operation is sent to a remote server. Only local-only fields can use the `@export` directive, and those fields are stripped from operations before they're transmitted. The remote server can therefore resolve operation fields in any order without side effects.
