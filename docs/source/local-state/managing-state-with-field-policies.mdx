---
title: Managing state with field policies
description: Control and reactively respond to local state changes
---

Field policies provide a way to manage data on its way into or out of the cache for specific fields in your GraphQL operations. They are explained in more detail in [Customizing the behavior of cached fields](../caching/cache-field-behavior/), but it's important to note that they can also be used help drive fields that don't actually exist in your cache. Field policies can be used to create virtual client side only fields that you can customize to perform any task, or return any data you would like, when called as part of your full GraphQL operation. They can be used to read and write from the cache or be combined with other state API's like Apollo Client reactive variables. Virtual fields are triggered anytime you call a GraphQL operation in Apollo Client, letting you blend fully custom local behavior with your remote queries, getting the results back in a combined response.

The following sections dive into more detail around reading and writing local state using field policies and the Apollo Client cache.

## Handling `@client` fields with field policies

Apollo Client [field policies](../caching/cache-field-behavior) can be used to locally compute GraphQL query fields that use a `@client` directive. This means that instead of sending your full GraphQL query to a remote GraphQL endpoint, which then runs resolver functions against your query to populate and return a result set, Apollo Client can run locally defined `read` functions to compute the value of `@client` fields. Let's look at an example:

```js
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const cache = new InMemoryCache({
  typePolicies: {
    Launch: {
      fields: {
        isInCart: {
          read(_, { variables }) {
            return localStorage.getItem('CART').includes(
              variables.launchId
            );
          }
        }
      }
    }
  }
});

const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache,
});

const GET_LAUNCH_DETAILS = gql`
  query LaunchDetails($launchId: ID!) {
    launch(id: $launchId) {
      isInCart @client
      site
      rocket {
        type
      }
    }
  }
`;

// ... run the query using client.query, a useQuery hook, etc.
```

Here when the `GET_LAUNCH_DETAILS` query is executed, Apollo Client looks for a field policy `read` function that is associated with the `isInCart` field. It finds one as we've defined a `read` function for the `isInCart` field in the `InMemoryCache` constructor. This `read` function is run, then the result is calculated and merged in with the rest of the query result (if a `read` function can't be found, Apollo Client will check the cache for a matching field - see [Local data query flow](./querying-and-updating#local-data-query-flow) for more details).

In the above example we defined and associated a `isInCart` `read` function with the `Launch` GraphQL object type. Let's look at the `isInCart` `read` function more closely:

```js
Launch: {
  fields: {
    isInCart: {
      read(_, { variables }) {
        return localStorage.getItem('CART').includes(
          variables.launchId
        );
      }
    }
  }
}
```

The first parameter of the `isInCart` `read` function gives us access to a previously stored `isInCart` field value from the cache, if one exists. Since we don't need to look at the cache in this example, we've named this parameter `_`. The second parameter is an object that gives us access to several read function properties and helper functions, which are explained in the [`FieldPolicy` API reference](../caching/cache-field-behavior/#fieldpolicy-api-reference). In our case we're only interested in using the `launchId` variable passed into the query, so we'll pull this out of the `variables` property. Using the `launchId` we check to see if our `localStorage` based cart array contains the specified launch, returning `true` / `false` accordingly. The returned boolean is then incorporated back into the result of running the original query, making it look like the value of `isInCart` came back alongside the rest of the server returned data.

Just like resolvers on the server, field policies are extremely flexible. They can be used to perform any kind of local computation you want, before returning a result for the specified field. You can manually query (or write to) the cache in different ways, call other helper utilities or libraries to prepare/validate/clean data, track statistics, call into other data stores to prepare a result, and so much more.

## Using reactive variables to track `@client` state

[Handling `@client` fields with field policies](#handling-client-fields-with-field-policies) outlines how field policies can be used to calculate query fields that use the `@client` directive. While this functionality is quite useful by itself, it can be paired with Apollo Client [reactive variables](./reactive-variables) to help make the processing and running of GraphQL queries more dynamic and reactive, to updates in other parts of your application.

To understand how reactive variables and field policies can work together, let's say we're building an ecommerce web application. As part of this system we're tracking items in a client side shopping cart, where the shopping cart is a simple list of product ID's. To list the items in the shopping cart, we're using the following query and `Cart` component:

```jsx
export const GET_CART_ITEMS = gql`
  query GetCartItems {
    cartItems @client
  }
`;

export function Cart() {
  const { data, loading, error } = useQuery(GET_CART_ITEMS);

  if (loading) return <Loading />;
  if (error) return <p>ERROR: {error.message}</p>;

  return (
    <div class="cart">
      <Header>My Cart</Header>
      {data && data.cartItems.length === 0 ? (
        <p>No items in your cart</p>
      ) : (
        <Fragment>
          {data && data.cartItems.map(productId => (
            <CartItem key={productId} launchId={productId} />
          ))}
        </Fragment>
      )}
    </div>
  );
}
```

The `@client` based `cartItems` field in the `GET_CART_ITEMS` query is calculated by the following locally defined `cartItems` field policy `read` function:

```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        cartItems: {
          read() {
            // Return all cart items from the client side cart
          }
        }
      }
    }
  }
});
```

To track the contents of our client side shopping cart, we have several options. We could store the cart contents in `localStorage`, we could write them directly into the Apollo Client cache using `cache.writeQuery`, we could store them using some other state management system like Redux, etc. While all of these choices have their advantages/disadvantages, the one thing we want to make sure of is that when a customer makes changes to their shopping cart, we want those changes to automatically trigger the rendering of our `Cart` component, to show the most recent state of the shopping cart.

Storing and managing our shopping cart in the Apollo Client cache would help address our requirement of re-rendering the `Cart` component when there are changes. `useQuery` watches for query changes in the cache, then automatically re-runs when it finds them. This means that we could follow a pattern of updating the shopping cart in the cache when a user makes changes to it, using `cache.writeQuery`, and reading from the cache in our `cartItems` field policy `read` function above, using `cache.readQuery`. While this would work, using `cache.writeQuery` / `cache.readQuery` introduces a fair amount of boilerplate to interact with the cache stored shopping cart. This boilerplate is important when we want to ensure the structure and integrity of the graph based data we're managing in the cache, but in our case the shopping cart is really just a simple list of product IDs. Wouldn't it be great if our shopping cart could just be a simple in-memory array, but have changes to the cart array tracked such that they're tied into Apollo Client's change broadcast system? In other words have changes made to the shopping cart array trigger a re-render of the `Cart` component, with the latest cart contents? Reactive variables to the rescue!

As mentioned in the [reactive variables](./reactive-variables) section of these docs, reactive variables give us a simple way to track client side state, while having changes to that state tracked using Apollo Client's dependency tracking mechanism. Let's take a look at how we can leverage a reactive variable to track our shopping cart state. First, let's setup a reactive variable:

```js:title=cache.js
export const cartItemsVar = cache.makeVar([]);
```

`cartItemsVar` will hold our shopping cart contents, and has been initialized as an empty array. Next, let's wire our new `cartItemsVar` reactive variable into our `cartItems` field policy:

```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        cartItems: {
          read() {
            return cartItemsVar();
          }
        }
      }
    }
  }
});
```

Now whenever our `cartItems` field policy is triggered, the current value of our cart reactive variable will be returned. This means that when our `GET_CART_ITEMS` query runs, its `cartItems @client` field will return the value of `cartItemsVar`.

Now that we've wired a reactive variable up to help display our cart contents, let's take a look at how we can add a new product to our cart:

```jsx
import { cartItemsVar } from './cache';
// ... other imports

export function AddToCartButton({ productId }) {
  const cartItems = cartItemsVar();
  return (
    <div class="add-to-cart-button">
      <Button onClick={() => cartItemsVar([...cartItems, productId])}>
        Add to Cart
      </Button>
    </div>
  );
}
```

When a customer clicks on our add to cart button, we combine the newly selected `productId` with the existing contents of our reactive variable cart, setting the new combination as the value of `cartItemsVar`. When this happens, Apollo Client notifies any query that has been wired up to use `cartItemsVar` in a field policy, of the changes. Since we're using `cartItems @client` in our `GET_CART_ITEMS` query above, this means our `useQuery` based `Cart` component will automatically re-render to show the updated cart.

If we wanted to store and manage our cart in the cache, to add a new product to the cart we would either fire a local mutation using something like `useMutation`, or manipulate the cache directly using something like `cache.writeQuery` / `cache.writeFragment`. Given the basic needs of our shopping cart however, leveraging reactive variables to manage cart data in a simple array, but still be able to participate in Apollo Client's change notification workflow, leads to less boilerplate and more flexibility. Apollo Client's cache is primarily optimized for storing normalized graph based data, which means the format of the data stored in the cache is restricted. While this can be adjusted by [disabling normalization](../caching/cache-configuration/#disabling-normalization), reactive variables have no restrictions when it comes to storing data. The are simple state containers, and can hold anything ranging from JSON to functions and more.

The above example really only scratches the surface of what reactive variables combined with field policies can accomplish. Reactive variables introduce a new exciting way of handling state in Apollo Client, and we can't wait to see what you build with them!

## Integrating `@client` into remote queries

While Apollo Client’s local state handling features can be used to work with local state exclusively, most Apollo based applications are built to work with remote data sources. To address this, Apollo Client supports mixing `@client` fields (calculated by field policies) with remote queries, as well as using `@client` based fields as arguments to remote queries, in the same request.

The `@client` directive can be used on any GraphQL selection set or field, to identify that the result of that field should be calculated locally with the help of a field policy:

```js
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const MEMBER_DETAILS = gql`
  query Member {
    member {
      name
      role
      isLoggedIn @client
    }
  }
`;

const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache({
    typePolicies: {
      Member: {
        fields: {
          isLoggedIn: {
            read() {
              return someInternalLoginVerificationFunction();
            }
          }
        }
      }
    }
  })
});

// ... run the query using client.query, a useQuery hook, etc.
```

When the above `MEMBER_DETAILS` query is fired by Apollo Client (assuming we're talking to a network based GraphQL API), the `@client` `isLoggedIn` field is first stripped from the document, and the remaining query is sent over the network to the GraphQL API. After the query has been handled by the remote resolvers and the result is passed back to Apollo Client from the API, the `@client` parts of the original query are then run against any defined cache field policies, their results are merged with the network results, and the final resulting data is returned as the response to the original operation. So in the above example, `isLoggedIn` is stripped before the rest of the query is sent and handled by the network API, then when the results come back `isLoggedIn` is calculated by running the `isLoggedIn` field policy `read` function. Local and network results are merged together, and the final response is made available to the application.

The `@client` directive can be used with entire selection sets as well:

```js
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const MEMBER_DETAILS = gql`
  query Member {
    member {
      name
      role
      session @client {
        isLoggedIn
        connectionCount
        errors
      }
    }
  }
`;

const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache({
    typePolicies: {
      Member: {
        fields: {
          session: {
            read() {
              return {
                isLoggedIn: someInternalLoginVerificationFunction(),
                connectionCount: calculateOpenConnections(),
                errors: sessionError(),
                __typename: 'Session',
              };
            }
          }
        }
      }
    }
  })
});
```

Apollo Client supports the merging of local `@client` results and remote results for Queries, Mutations and Subscriptions.

## Handling async operations with field policies

TODO

## Handling `@client` fields with the cache

As outlined in [Handling `@client` fields with field policies](#handling-client-fields-with-field-policies), `@client` fields can be resolved with the help of field policy functions. However, it's important to note that field policies are not always required when using the `@client` directive. Fields marked with `@client` can still be resolved locally, by pulling matching values out of the cache directly. For example:

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import {
  ApolloClient,
  InMemoryCache,
  ApolloProvider,
  useQuery,
  gql
} from '@apollo/client';

import Pages from './pages';
import Login from './pages/login';

const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache(),
});

const IS_LOGGED_IN = gql`
  query IsUserLoggedIn {
    isLoggedIn @client
  }
`;

cache.writeQuery({
  query: IS_LOGGED_IN,
  data: {
    isLoggedIn: !!localStorage.getItem("token"),
  },
});

function App() {
  const { data } = useQuery(IS_LOGGED_IN);
  return data.isLoggedIn ? <Pages /> : <Login />;
}

ReactDOM.render(
  <ApolloProvider client={client}>
    <App />
  </ApolloProvider>,
  document.getElementById("root"),
);
```

In the above example, we first prepare the cache using `cache.writeQuery` to store a value for the `isLoggedIn` field. We then run the `IS_LOGGED_IN` query via an Apollo Client `useQuery` hook, which includes an `@client` directive. When Apollo Client executes the `IS_LOGGED_IN` query, it first looks for a field policy function that can be used to handle the `@client` field. When it can't find one, it falls back on trying to pull the specified field out of the cache. So in this case, the `data` value returned by the `useQuery` hook has a `isLoggedIn` property available, which includes the `isLoggedIn` result (`!!localStorage.getItem('token')`) pulled directly from the cache.

Pulling `@client` field values directly out of the cache isn't quite as flexible as using field policy functions, since they can perform extra computations before returning a result. Depending on your application's needs however, loading `@client` fields directly from the cache might be a simpler option. Apollo Client doesn't restrict combining both approaches, so feel free to mix and match. If the need arises, you can pull some `@client` values directly from the cache, and calculate others others using field policies, all in the same query.

## Using `@client` fields as variables

Apollo Client provides a way to use an `@client` field result as a variable for a selection set or field, in the same operation. So instead of running an `@client` based query first, getting the local result, then running a second query using the loaded local result as a variable, everything can be handled in one request. This is achieved by combining the `@client` directive with the `@export(as: "variableName")` directive:

```js
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const query = gql`
  query CurrentAuthorPostCount($authorId: Int!) {
    currentAuthorId @client @export(as: "authorId")
    postCount(authorId: $authorId)
  }
`;

const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache(),
});

cache.writeQuery({
  query: gql`query GetCurrentAuthorId { currentAuthorId }`,
  data: {
    currentAuthorId: 12345,
  },
});

// ... run the query using client.query, useQuery hook, etc.
```

In the example above, `currentAuthorId` is first loaded from the cache, then passed into the subsequent  `postCount` field as the `authorId` variable (specified by the `@export(as: "authorId")` directive). The `@export` directive can also be used on specific fields within a selection set, like:

```js
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const query = gql`
  query CurrentAuthorPostCount($authorId: Int!) {
    currentAuthor @client {
      name
      authorId @export(as: "authorId")
    }
    postCount(authorId: $authorId)
  }
`;

const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache(),
});

cache.writeQuery({
  query: gql`
    query GetCurrentAuthor {
      currentAuthor {
        name
        authorId
      }
    }
  `,
  data: {
    currentAuthor: {
      __typename: 'Author',
      name: 'John Smith',
      authorId: 12345,
    },
  },
});

// ... run the query using client.query, useQuery hook, etc.
```

Here the `authorId` variable is set from the `authorId` field loaded from the cache stored `currentAuthor`. `@export` variable use isn't limited to remote queries; it can also be used to define variables for other `@client` fields or selection sets:

```js
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const query = gql`
  query CurrentAuthorPostCount($authorId: Int!) {
    currentAuthorId @client @export(as: "authorId")
    postCount(authorId: $authorId) @client
  }
`;

const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        postCount: {
          read(_, { variables }) {
            return variables.authorId === 12345 ? 100 : 0;
          }
        }
      }
    }
  }
});

const client = new ApolloClient({ cache });

cache.writeQuery({
  query: gql`{ currentAuthorId }`,
  data: {
    currentAuthorId: 12345,
  },
});

// ... run the query using client.query, useQuery hook, etc.
```

So here the `currentAuthorId` is loaded from the cache, then passed into the `postCount` local resolver as `authorId`.

**A few important notes about `@export` use:**

1. Apollo Client currently only supports using the `@export` directive to store variables for local data. `@export` must be used with `@client`.

2. `@client @export` use might appear to go against the GraphQL specification, given that the execution order of an operation looks like it could affect the result. From the [Normal and Serial Execution](https://graphql.github.io/graphql-spec/draft/#sec-Normal-and-Serial-Execution) section of the GraphQL spec:

  > ... the resolution of fields other than top‐level mutation fields must always be side effect‐free and idempotent, the execution order must not affect the result, and hence the server has the freedom to execute the field entries in whatever order it deems optimal.

  Apollo Client currently only supports the use of the `@export` directive when mixed with the `@client` directive. It prepares `@export` variables by first running through an operation that has `@client @export` directives, extracting the specified `@export` variables, then attempting to resolve the value of those variables from the local cache or with field policies. Once a map of variable names to local values is built up, that map is then used to populate the variables passed in when running the server based GraphQL query. The execution order of the server based GraphQL query is not impacted by `@export` use; the variables are prepped and organized before the server query runs, so the specification is being followed.

3. If you define multiple `@export` variables that use the same name, in a single operation, the value of the last `@export` variable will be used as the variable value moving forward. When this happens Apollo Client will log a warning message (dev only).
