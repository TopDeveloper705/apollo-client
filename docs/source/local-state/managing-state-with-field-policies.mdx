---
title: Local-only fields
sidebar_title: Local-only fields
description: Fetch both local and remote data in a single query
---

import { ExpansionPanel } from 'gatsby-theme-apollo-docs/src/components/expansion-panel';

Your Apollo Client queries can include **local-only fields** that _aren't_ defined in your GraphQL server's schema. The values for these fields are calculated locally using any logic you want. A single query can include both local-only fields _and_ fields that are fetched from your GraphQL server.

## Use the `@client` directive

Let's say we're building an e-commerce application. Most of a product's details are stored on our back-end server, but we want to define an `isInCart` boolean field that's local to the client.

We can fetch a particular product's details (_including_ its local cart status) with a query like this one:

```js{6}
const GET_PRODUCT_DETAILS = gql`
  query ProductDetails($productId: ID!) {
    product(id: $productId) {
      name
      price
      isInCart @client
    }
  }
`;
```

The `@client` directive tells Apollo Client that `isInCart` is a local-only field. To prevent errors, Apollo Client strips this field from the query before sending it to our server to fetch `name` and `price`. The final query result is returned only after all local _and_ remote fields are populated.

> **Note:** If you apply the `@client` directive to a field with subfields, the directive is automatically applied to all subfields.
> 
> <ExpansionPanel title="See example">
> 
> ```js{6-9}
> const GET_PRODUCT_DETAILS = gql`
  query ProductDetails($productId: ID!) {
    product(id: $productId) {
      name
      price
      purchaseStatus @client {
        isInCart
        isOnWishlist
      }
    }
  }
`;
> ```
>
> </ExpansionPanel>

Next, we need to define exactly _how_ the `isInCart` field is calculated locally. To do that, we'll [define a field policy](#define-a-field-policy) for it.

## Define a field policy

A **field policy** specifies custom logic for how a single GraphQL field is fetched from and written to your Apollo Client cache. You can define field policies for both local-only fields and remotely fetched fields.

> Field policies are primarily documented in [Customizing the behavior of cached fields](../caching/cache-field-behavior/). This article specifically describes how to use them with local-only fields.

You define your application's field policies in a map that you provide to the constructor of Apollo Client's `InMemoryCache`. Each field policy is a child of a particular _type_ policy (much like the corresponding field is a child of a particular type).

Here's a sample `InMemoryCache` constructor that defines a field policy for `Product.isInCart`:

```js
const cache = new InMemoryCache({
  typePolicies: { // Type policy map
    Product: {
      fields: { // Field policy map for the Product type
        isInCart: { // Field policy for the isInCart field
          read(_, { variables }) { // The read function for the isInCart field
            return localStorage.getItem('CART').includes(
              variables.productId
            );
          }
        }
      }
    }
  }
});
```

The field policy above defines a [`read` function](../caching/cache-field-behavior/#the-read-function) for the `isInCart` field. Whenever you query a field that has a `read` function, the cache calls that function to calculate the field's value. In this case, the `read` function returns whether the queried product's ID is in the `CART` array in `localStorage`.

You can use `read` functions to perform any sort of logic you want, including:

* Manually executing other cache operations
* Calling helper utilities or libraries to prepare, validate, or sanitize data
* Fetching data from a separate store
* Logging usage metrics

> If you query a local-only field that _doesn't_ define a `read` function, Apollo Client performs a default cache lookup for the field. See [Storing local data in the cache](#storing-local-data-in-the-cache) for details.

## Storing local state

[As covered above](#define-a-field-policy), you can use Apollo Client to query local state, regardless of how you _store_ that state. Apollo Client provides a couple of helpful mechanisms for storing local state:

* [Reactive variables](#storing-local-data-in-reactive-variables) (recommended) 
* [The Apollo Client cache itself](#storing-local-data-in-the-cache)

### Storing local state in reactive variables

You can access Apollo Client [reactive variables](./reactive-variables) anywhere in your application, and they integrate powerfully with [field policies](#define-a-field-policy). If a field's `read` function relies on the value of a reactive variable, and that variable's value _changes_, **every active query that includes the field automatically updates**.

#### Example

Returning to our e-commerce application, let's say we want to fetch a list of the item IDs in a user's cart, and this list is stored locally. The query to do that looks like this:

```js
const GET_CART_ITEMS = gql`
  query GetCartItems {
    cartItems @client
  }
`;
```

Let's initialize a reactive variable to store our local list of cart items, like so:

```js
const cartItemsVar = makeVar([]);
```

This initializes a reactive variable with an empty array as its value. We can get this variable's current value by calling `cartItemsVar()`, and we can set a _new_ value by calling `cartItemsVar(newValue)`.

Next, let's define the `read` function for the `cartItems` field. As always, we pass this function to the constructor of `InMemoryCache`: 

```js{6-8}
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        cartItems: {
          read() {
            return cartItemsVar();
          }
        }
      }
    }
  }
});
```

Now the value of our reactive variable is returned whenever we query `cartItems`.

To list the items in the shopping cart, we're using the following query and `Cart` component:

```jsx
export const GET_CART_ITEMS = gql`
  query GetCartItems {
    cartItems @client
  }
`;

export function Cart() {
  const { data, loading, error } = useQuery(GET_CART_ITEMS);

  if (loading) return <Loading />;
  if (error) return <p>ERROR: {error.message}</p>;

  return (
    <div class="cart">
      <Header>My Cart</Header>
      {data && data.cartItems.length === 0 ? (
        <p>No items in your cart</p>
      ) : (
        <Fragment>
          {data && data.cartItems.map(productId => (
            <CartItem key={productId} launchId={productId} />
          ))}
        </Fragment>
      )}
    </div>
  );
}
```

As mentioned in the [reactive variables](./reactive-variables) section of these docs, reactive variables give us a simple way to track client side state, while having changes to that state tracked using Apollo Client's dependency tracking mechanism. 

Now that we've wired a reactive variable up to help display our cart contents, let's take a look at how we can add a new product to our cart:

```jsx
import { cartItemsVar } from './cache';
// ... other imports

export function AddToCartButton({ productId }) {
  const cartItems = cartItemsVar();
  return (
    <div class="add-to-cart-button">
      <Button onClick={() => cartItemsVar([...cartItems, productId])}>
        Add to Cart
      </Button>
    </div>
  );
}
```

When a customer clicks on our add to cart button, we combine the newly selected `productId` with the existing contents of our reactive variable cart, setting the new combination as the value of `cartItemsVar`. When this happens, Apollo Client notifies any query that has been wired up to use `cartItemsVar` in a field policy, of the changes. Since we're using `cartItems @client` in our `GET_CART_ITEMS` query above, this means our `useQuery` based `Cart` component will automatically re-render to show the updated cart.

If we wanted to store and manage our cart in the cache, to add a new product to the cart we would either fire a local mutation using something like `useMutation`, or manipulate the cache directly using something like `cache.writeQuery` / `cache.writeFragment`. Given the basic needs of our shopping cart however, leveraging reactive variables to manage cart data in a simple array, but still be able to participate in Apollo Client's change notification workflow, leads to less boilerplate and more flexibility. Apollo Client's cache is primarily optimized for storing normalized graph based data, which means the format of the data stored in the cache is restricted. While this can be adjusted by [disabling normalization](../caching/cache-configuration/#disabling-normalization), reactive variables have no restrictions when it comes to storing data. The are simple state containers, and can hold anything ranging from JSON to functions and more.

The above example really only scratches the surface of what reactive variables combined with field policies can accomplish. Reactive variables introduce a new exciting way of handling state in Apollo Client, and we can't wait to see what you build with them!

### Storing local state in the cache

TODO: Storing and managing our shopping cart in the Apollo Client cache would help address our requirement of re-rendering the `Cart` component when there are changes. `useQuery` watches for query changes in the cache, then automatically re-runs when it finds them. This means that we could follow a pattern of updating the shopping cart in the cache when a user makes changes to it, using `cache.writeQuery`, and reading from the cache in our `cartItems` field policy `read` function above, using `cache.readQuery`. While this would work, using `cache.writeQuery` / `cache.readQuery` introduces a fair amount of boilerplate to interact with the cache stored shopping cart.

If you store local state as fields in the Apollo Client cache, you don't _have_ to [define `read` functions](#define-a-field-policy) for those fields. This is because if you query a field that doesn't define a `read` function, Apollo Client defaults to fetching that field's value directly from the cache.

#### Example

Let's say our application defines the following query:

```js
const IS_LOGGED_IN = gql`
  query IsUserLoggedIn {
    isLoggedIn @client
  }
`;
```

The `isLoggedIn` field of this query is a local-only field. We can use [the `writeQuery` method](../caching/cache-interaction/#writequery-and-writefragment) to write a value for this field directly to the Apollo Client cache, like so:

```js
cache.writeQuery({
  query: IS_LOGGED_IN,
  data: {
    isLoggedIn: !!localStorage.getItem("token"),
  },
});
```

This writes a boolean value according to whether `localStorage` includes a `token` item, indicating an active session.

Now our application's components can render according to the value of the `isLoggedIn` field, _without_ our needing to define a `read` function for it:

```js
function App() {
  const { data } = useQuery(IS_LOGGED_IN);
  return data.isLoggedIn ? <Pages /> : <Login />;
}
```

Here's a full example that incorporates the code blocks above:

<ExpansionPanel title="Expand example">

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import {
  ApolloClient,
  InMemoryCache,
  ApolloProvider,
  useQuery,
  gql
} from '@apollo/client';

import Pages from './pages';
import Login from './pages/login';

const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache(),
});

const IS_LOGGED_IN = gql`
  query IsUserLoggedIn {
    isLoggedIn @client
  }
`;

cache.writeQuery({
  query: IS_LOGGED_IN,
  data: {
    isLoggedIn: !!localStorage.getItem("token"),
  },
});

function App() {
  const { data } = useQuery(IS_LOGGED_IN);
  return data.isLoggedIn ? <Pages /> : <Login />;
}

ReactDOM.render(
  <ApolloProvider client={client}>
    <App />
  </ApolloProvider>,
  document.getElementById("root"),
);
```

</ExpansionPanel>

Note that even if you _do_ store local data as fields in the Apollo Client cache, you can (and probably should!) still define `read` functions for those fields. A `read` function can execute helpful custom logic, such as returning a default value if a field isn't present in the cache.

## Using local-only fields as GraphQL variables

If your GraphQL query uses variables, the local-only fields of that query can provide the _values_ of those variables.

To do so, you apply the `@export(as: "variableName")` directive, like so:

```js
const GET_CURRENT_AUTHOR_POST_COUNT = gql`
  query CurrentAuthorPostCount($authorId: Int!) {
    currentAuthorId @client @export(as: "authorId")
    postCount(authorId: $authorId)
  }
`;
```

In the query above, the result of the local-only field `currentAuthorId` is used as the value of the `$authorId` variable that's passed to `postCount`. 

You can do this even if `postCount` is _also_ a local-only field (i.e., if it's also marked as `@client`).

### Considerations for using `@export`

* To use the `@export` directive, a field **must also** use the `@client` directive. In other words, only local-only fields can be used as variable values.

* A field that `@export`s a variable value **must appear before** any fields that _use_ that variable.

* If multiple fields in an operation use the `@export` directive to assign their value to the _same_ variable, the field listed _last_ takes precedence. When this happens in development mode, Apollo Client logs a warning message.

* At first glance, the `@export` directive appears to violate the [GraphQL specification's requirement](https://graphql.github.io/graphql-spec/draft/#sec-Normal-and-Serial-Execution) that the execution order of an operation must not affect its result:

    > …the resolution of fields other than top‐level mutation fields must always be side effect‐free and idempotent, the execution order must not affect the result, and hence the server has the freedom to execute the field entries in whatever order it deems optimal.

    However, all `@export`ed variable values are populated _before_ an operation is sent to a remote server. Only local-only fields can use the `@export` directive, and those fields are stripped from operations before they're transmitted.
