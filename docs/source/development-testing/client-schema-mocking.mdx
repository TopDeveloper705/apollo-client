---
title: Mocking new schema capabilities
description: Build client features before your server supports them
---

If your GraphQL server doesn't yet support a field that your client needs, you can still start building against that field by mocking its behavior within the client.

For example, let's say we want to add a feature to the Space Explorer app from [the Apollo full-stack tutorial](https://www.apollographql.com/docs/tutorial/introduction/). Specifically, we want to display a description of the rocket used for each launch. To support this functionality on the server side, we'll add a `description` field to our schema's `Rocket` type:

```graphql{5}
type Rocket {
  id: ID!
  name: String
  type: String
  description: String # field not yet supported
}
```

But what if our team won't finish adding support for that field for at least another two weeks? By mocking the field's behavior, we can still start developing the feature in our client. To accomplish this, we'll define `Rocket.description` as a **local-only field**.

## 1. Define a client-side schema (recommended)

Your client application can define a [client-side schema](../local-state/client-side-schema/) that extends types from your server  or even defines entirely new types. The syntax is identical to server-side schema definitions.

> Although a client-side schema isn't _required_ to define local-only fields, it helps team members understand your app's local state. It also unlocks powerful local state support in tools like the [Apollo Client Devtools](./developer-tooling/#apollo-client-devtools) and the [Apollo extension for VS Code](https://www.apollographql.com/docs/devtools/editor-plugins/).

This client-side schema extends the `Rocket` type to add a `description` field (make sure to name the variable `typeDefs`):

```js:title=index.js
const typeDefs = gql`
  extend type Rocket {
    description: String
  }
`;
```

We can then provide this schema to the `ApolloClient` constructor, like so:

```js{4}:title=index.js
const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache(),
  typeDefs
});
```

## 2. Introduce richer mock data.

Now that we have a basic resolver, we might find that during testing it's a bit boring to show the same boilerplate text every time. In fact we might want to test different lengths of text to make sure our layout still looks good. Introducing a mock data helper library such as [faker.js](https://github.com/marak/Faker.js/) can help keep the mock data varied while testing. We can incorporate it easily into this workflow:

```js
import faker from "faker/locale/en";

// returns either 1 or 2 latin sentences, like
// 'Lorem ipsum dolor sit amet, consectetur adipiscing elit...
const oneOrTwoSentences = () =>
  faker.lorem.sentences(Math.random() < 0.5 ? 1 : 2);

const resolvers = {
  Rocket: {
    description: () => oneOrTwoSentences()
  }
};
```

> _Note:_ the faker.js library comes bundled with lots and lots of strings that can consume precious bundle bytes. For this reason you should make sure to only include the faker.js dependency in development mode and take care not to include this in your production bundle.

## 3. Query the mocked field with the `@client` directive.

Now, you’re ready to query your new field inside the `RocketDetails` component. Just add your new field to the query and specify the `@client` directive, and start using it in your UI.

```jsx
const GET_ROCKET_DETAILS = gql`
  query RocketDetails($rocketId: ID!) {
    rocket(id: $rocketId) {
      type
      description @client
    }
  }
`;

export default function RocketDetails({ rocketId }) {
  const { data } = useQuery(GET_ROCKET_DETAILS, { variables: { rocketId } });
  return (
    <div>
      <p>Rocket Type: {data.rocket.type}</p>
      <p>Description: {data.rocket.description}</p>
    </div>
  );
}
```

## 4. Toggle on “real” data.

Once the feature is ready on the backend, just remove the `@client` directive from your query. You should now be able to see your real production data returned instead. It's probably a good idea to clean up any unused client schema and resolvers at this time.

There you have it, a workflow for developing new features with new schema fields ahead of the actual schema implementation. For further reading, visit the [tutorial guide](https://www.apollographql.com/docs/tutorial/local-state.html#virtual-fields) which describes how to use client fields to manage local state in greater depth.

If you have feedback on this workflow, experiences you want to share, or just want to join the general discussion on client-side development and mocking, join us on [Spectrum](https://spectrum.chat/apollo)!
