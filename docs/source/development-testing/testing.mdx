---
title: Testing React components
description: Using MockedProvider and associated APIs
---

import {
  ExpansionPanel,
} from 'gatsby-theme-apollo-docs/src/components/expansion-panel';

This article describes best practices for testing React components that use Apollo Client.

The examples below use [Jest](https://facebook.github.io/jest/docs/en/tutorial-react.html) and React's [test renderer](https://reactjs.org/docs/test-renderer.html) instead of tools like [Enzyme](https://github.com/airbnb/enzyme) or [react-testing-library](https://github.com/kentcdodds/react-testing-library), but the concepts apply to any testing framework.

## The `MockedProvider` component

Every test for a React component that uses Apollo Client must make Apollo Client available on [React's context](https://reactjs.org/docs/context.html). In application code, you achieve this by wrapping your component tree with the `ApolloProvider` component. In your tests, you use the `MockedProvider` component instead.

The `MockedProvider` component enables you to define mock responses for individual queries that are executed in your test. This means your test _doesn't_ need to communicate with a GraphQL server, which removes an external dependency and therefore improves the test's reliability.

### Example

Let's say we want to test the following `Dog` component, which executes a basic query and displays its result:

<ExpansionPanel title="Click to expand 🐶">

```jsx:title=dog.jsx
import React from 'react';
import { gql, useQuery } from '@apollo/client';

// Make sure that both the query and the component are exported
export const GET_DOG_QUERY = gql`
  query GetDog($name: String) {
    dog(name: $name) {
      id
      name
      breed
    }
  }
`;

export function Dog({ name }) {
  const { loading, error, data } = useQuery(
    GET_DOG_QUERY,
    { variables: { name } }
  );
  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error!</p>;

  return (
    <p>
      {data.dog.name} is a {data.dog.breed}
    </p>
  );
}
```

</ExpansionPanel>

A basic rendering test for the component looks like this (minus mocked responses):

```jsx:title=dog.test.js
import TestRenderer from 'react-test-renderer';
import { MockedProvider } from '@apollo/client/testing';
import { GET_DOG_QUERY, Dog } from './dog';

const mocks = []; // We'll fill this in next

it('renders without error', () => {
  TestRenderer.create(
    <MockedProvider mocks={mocks} addTypename={false}>
      <Dog name="Buck" />
    </MockedProvider>,
  );
});
```

#### Defining mocked responses

The `mocks` prop of `MockedProvider` is an array of objects, each of which defines the mock response for a single operation. Let's define a mocked response for `GET_DOG_QUERY` when it's passed the `name` `Buck`:

```jsx:title=dog.test.js
const mocks = [
  {
    request: {
      query: GET_DOG_QUERY,
      variables: {
        name: 'Buck',
      },
    },
    result: {
      data: {
        dog: { id: '1', name: 'Buck', breed: 'bulldog' },
      },
    },
  },
];
```

Each mock object defines a `request` field (indicating the shape and variables of the operation to match against) and a `result` field (indicating the shape of the response to return for that operation).

> **Your test must execute an operation that _exactly_ matches a mock's shape _and_ variables to receive the associated mocked response.**

Alternatively, the `result` field can be a function that returns a mocked response after performing arbitrary logic:

```jsx
result: () => {
  // ...arbitrary logic...

  return {
    data: {
      dog: { id: '1', name: 'Buck', breed: 'bulldog' },
    },
  }
},
```

Combining our code above, we get the following complete test:

<ExpansionPanel title="Click to expand 🐶">

```jsx:title=dog.test.js
import TestRenderer from 'react-test-renderer';
import { MockedProvider } from '@apollo/client/testing';
import { GET_DOG_QUERY, Dog } from './dog';

const mocks = [
  {
    request: {
      query: GET_DOG_QUERY,
      variables: {
        name: 'Buck',
      },
    },
    result: {
      data: {
        dog: { id: '1', name: 'Buck', breed: 'bulldog' },
      },
    },
  },
];

it('renders without error', () => {
  TestRenderer.create(
    <MockedProvider mocks={mocks} addTypename={false}>
      <Dog name="Buck" />
    </MockedProvider>,
  );
});
```

</ExpansionPanel>

> **Important:** As it's written, this test checks whether the `Dog` component renders successfully, but it _doesn't_ wait for `MockedProvider` to respond to `GET_DOG_QUERY`. Even when GraphQL operations are mocked, they're `Promise`-based and therefore asynchronous. Because of this, this test always completes while the component is still in its initial [loading state](#the-loading-state).
>
> To test a component's rendering _after_ `MockedProvider` responds, see [The "completed" state](#the-completed-state) and [Error states](#error-states).

### The `addTypename` prop

In the example above, we set the `addTypename` prop of `MockedProvider` to `false`. This prevents Apollo Client from automatically adding the special `__typename` field to every object it queries for (it does this by default to support data normalization in the cache).

We _don't_ want to automatically add `__typename` to `GET_DOG_QUERY` in our test, because then it won't match the shape of the query that our mock is expecting.

Unless you explicitly configure your mocks to expect a `__typename` field, always set `addTypename` to `false` in your tests.

## The "loading" state

You can test how your component is rendered while it's still loading a query result. To do so, provide an empty array to the `mocks` prop of `MockedProvider`, like so:

```jsx
it('should render loading state initially', () => {
  const component = TestRenderer.create(
    <MockedProvider mocks={[]}>
      <Dog />
    </MockedProvider>,
  );

  const tree = component.toJSON();
  expect(tree.children).toContain('Loading...');
});
```

When the `Dog` component executes `GET_DOG_QUERY`, `MockedProvider` returns a `Promise`.

In this example, the `Dog` component will render, but it will render in a loading state, not the final response state. This is because `MockedProvider` doesn't just return the data but instead returns a `Promise` that will resolve to that data.  By using a `Promise` it enables testing of the loading state in addition to the final state:



This shows a basic example test that tests the loading state of a component by checking that the children of the component contain the text `Loading...`. In an actual application, this test would probably be more complicated, but the testing logic would be the same.

## The "completed" state

Loading state, while important, isn't the only thing to test. To test the final state of the component after receiving data, we can just wait for it to update and test the final state.

```jsx
it('should render dog', async () => {
  const dogMock = {
    request: {
      query: GET_DOG_QUERY,
      variables: { name: 'Buck' },
    },
    result: {
      data: { dog: { id: 1, name: 'Buck', breed: 'poodle' } },
    },
  };

  const component = TestRenderer.create(
    <MockedProvider mocks={[dogMock]} addTypename={false}>
      <Dog name="Buck" />
    </MockedProvider>,
  );

  await new Promise(resolve => setTimeout(resolve, 0)); // wait for response

  const p = component.root.findByType('p');
  expect(p.children).toContain('Buck is a poodle');
});
```

The Promise below `TestRenderer.create` delays until the next "tick" of the event loop, and allows time for that `Promise` returned from `MockedProvider` to be fulfilled. After that `Promise` resolves (or rejects), the component can be checked to ensure it displays the correct information — in this case, "Buck is a poodle".

For more complex UI with heavy calculations, or delays added into its render logic, you may want to increase the wait time. You could also use a package like [`wait-for-expect`](https://npm.im/wait-for-expect) to delay until the render has happened. The risk of using a package like this everywhere by default is that _every_ test could take up to five seconds to execute (or longer if the default timeout has been increased).

## Error states

Your component's error states are just as important to test as its success states, if not more so. You can use the `MockedProvider` component to simulate both network errors and GraphQL errors.

* Network errors are errors that occur while your client attempts to communicate with your GraphQL server.
* GraphQL errors are errors that occur while your GraphQL server attempts to resolve your client's operation.

### Network errors

To simulate a network error, you can include an `error` field in your test's mock object, instead of the `result` field:

```jsx
it('should show error UI', async () => {
  const dogMock = {
    request: {
      query: GET_DOG_QUERY,
      variables: { name: 'Buck' },
    },
    error: new Error('An error occurred'),
  };

  const component = TestRenderer.create(
    <MockedProvider mocks={[dogMock]} addTypename={false}>
      <Dog name="Buck" />
    </MockedProvider>,
  );

  await new Promise(resolve => setTimeout(resolve, 0)); // wait for response

  const tree = component.toJSON();
  expect(tree.children).toContain('Error!');
});
```

In this case, when the `Dog` component executes its query, the `MockedProvider` returns the corresponding error. This applies the error state to our `Dog` component, enabling us to verify that the error is handled gracefully.

### GraphQL errors

To simulate GraphQL errors, you define an `errors` field _inside_ a mock's `result` field. The value of this field is an array of instantiated `GraphQLError` objects:

```js
const dogMock = {
  // ...
  result: {
    errors: [new GraphQLError('Error!')],
  },
};
```

Because GraphQL supports returning partial results when an error occurs, a mock object's `result` can include both `errors` _and_ `data`.

## Mutation components

`useMutation` based components are tested very similarly to `useQuery` components. The only key difference is how the operation is fired. With `useQuery` the query is fired when the wrapping component _mounts_, whereas with `useMutation` the mutation is fired manually, usually after some user interaction like pressing a button.

Consider this component that calls a mutation:

```jsx
export const DELETE_DOG_MUTATION = gql`
  mutation deleteDog($name: String!) {
    deleteDog(name: $name) {
      id
      name
      breed
    }
  }
`;

export function DeleteButton() {
  const [mutate, { loading, error, data }] = useMutation(DELETE_DOG_MUTATION);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error!</p>;
  if (data) return <p>Deleted!</p>;

  return (
    <button onClick={() => mutate({ variables: { name: 'Buck' } })}>
      Click me to Delete Buck!
    </button>
  );
}
```

Testing an initial render for this component looks identical to testing our `useQuery` based component.

```jsx
import DeleteButton, { DELETE_DOG_MUTATION } from './delete-dog';

it('should render without error', () => {
  TestRenderer.create(
    <MockedProvider mocks={[]}>
      <DeleteButton />
    </MockedProvider>,
  );
});
```

Calling the mutation is where things get interesting:

```jsx
it('should render loading state initially', () => {
  const deleteDog = { name: 'Buck', breed: 'Poodle', id: 1 };
  const mocks = [
    {
      request: {
        query: DELETE_DOG_MUTATION,
        variables: { name: 'Buck' },
      },
      result: { data: { deleteDog } },
    },
  ];

  const component = TestRenderer.create(
    <MockedProvider mocks={mocks} addTypename={false}>
      <DeleteButton />
    </MockedProvider>,
  );

  // find the button and simulate a click
  const button = component.root.findByType('button');
  button.props.onClick(); // fires the mutation

  const tree = component.toJSON();
  expect(tree.children).toContain('Loading...');
});
```

This example looks very similar to the `useQuery` based component above, but the difference comes after the rendering is completed. Since this component relies on a button to be clicked to fire a mutation, the renderer's API is used to find the button.

After a reference to the button has been obtained, a "click" on the button can be simulated by calling its `onClick` handler. This will fire off the mutation, and then the rest will be tested identically to the `useQuery` based component.

> Note: Other test utilities like [Enzyme](https://github.com/airbnb/enzyme) and [react-testing-library](https://github.com/kentcdodds/react-testing-library) have built-in tools for finding elements and simulating events, but the concept is the same: find the button and simulate a click on it.

To test for a successful mutation after simulating the click, the fulfilled `Promise` from `MockedProvider` can be checked for the appropriate confirmation message, just like the `useQuery` based component:

```jsx
it('should delete and give visual feedback', async () => {
  const deleteDog = { name: 'Buck', breed: 'Poodle', id: 1 };
  const mocks = [
    {
      request: {
        query: DELETE_DOG_MUTATION,
        variables: { name: 'Buck' },
      },
      result: { data: { deleteDog } },
    },
  ];

  const component = TestRenderer.create(
    <MockedProvider mocks={mocks} addTypename={false}>
      <DeleteButton />
    </MockedProvider>,
  );

  // find the button and simulate a click
  const button = component.root.findByType('button');
  button.props.onClick(); // fires the mutation

  await new Promise(resolve => setTimeout(resolve, 0)); // wait for response

  const tree = component.toJSON();
  expect(tree.children).toContain('Deleted!');
});
```

The `result` in a mocked mutation may be a function rather than an object. This gives you a simple way to check that a mutation has been called:

```js
it('should delete and give visual feedback', async () => {
  const deleteDog = { name: 'Buck', breed: 'Poodle', id: 1 };
  let deleteMutationCalled = false;
  const mocks = [
    {
      request: {
        query: DELETE_DOG_MUTATION,
        variables: { name: 'Buck' },
      },
      result: () => {
        deleteMutationCalled = true;
        return { data: { deleteDog } };
      },
    },
  ];

  const component = TestRenderer.create(
    <MockedProvider mocks={mocks} addTypename={false}>
      <DeleteButton />
    </MockedProvider>,
  );

  // find the button and simulate a click
  const button = component.root.findByType('button');
  button.props.onClick(); // fires the mutation

  await new Promise(resolve => setTimeout(resolve, 0)); // wait for response

  expect(deleteMutationCalled).toBe(true);

  const tree = component.toJSON();
  expect(tree.children).toContain('Deleted!');
});
```

For the sake of simplicity, the error case for mutations hasn't been shown here, but testing `useMutation` errors is exactly the same as testing `useQuery` errors: just add an `error` to the mock, fire the mutation, and check the UI for error messages.

## A note on fragment usage, `typePolicies`, and `possibleTypes`

When using fragments with polymorphic types such as the following:
```jsx
// "Dog" supertype can be of type "ShibeInu"
const ShibeFragment = gql`
  fragment ShibeInuFields on Dog {
    ... on ShibeInu {
      tail {
        isCurly
      }
    }
  }
`;

export const GET_DOG_QUERY = gql`
  query GetDog($name: String) {
    dog(name: $name) {
      id
      name
      breed

      ...ShibeInuFields
    }
  }

  ${ShibeFragment}
`;

export const cache = new ApolloClient({
  cache: new InMemoryCache({
    possibleTypes: {
      Dog: ['ShibeInu']
    },
    // suppose you want you key fields for "Dog" to not be simply "id"
    typePolicies: {
      keyFields: {
        Dog: ['name', 'breed']
      }
    }
  })
})
```

You must configure your cache when testing a component which utilizes fragments in its queries, and pass it to the `<MockedProvider>` via the `cache={cache}` attribute, configured with `possibleTypes` and `typePolicies` just the same as in your application:

```jsx
<MockedProvider cache={cache}>
  <DeleteButton />
</MockedProvider>,
```

Testing UI components isn't a simple issue, but hopefully these tools will create confidence when testing components that are dependent on data.

For a working example showing how to test components, check out this project on CodeSandbox:

[![Edit React-Apollo Testing](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/40k7j708n4)
